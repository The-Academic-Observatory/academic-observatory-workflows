{#
  # Copyright 2020 Curtin University
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #   http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed on an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.
  # Author: Richard Hosking
#}

-- Helper Function: Processing Output Types
{#
  Output Schema:
  per_25th FLOAT NULLABLE
  median   FLOAT NULLABLE
  per_90th FLOAT NULLABLE
  per_95th FLOAT NULLABLE
#}
CREATE TEMP FUNCTION compute_percentiles(counts ARRAY<INT64>) AS ((
  SELECT AS STRUCT
    ROUND(PERCENTILE_CONT(count, 0.25) OVER(), 2) AS per_25th,
    ROUND(PERCENTILE_CONT(count, 0.50) OVER(), 2) AS median,
    ROUND(PERCENTILE_CONT(count, 0.90) OVER(), 2) AS per_90th,
    ROUND(PERCENTILE_CONT(count, 0.95) OVER(), 2) AS per_95th
  FROM UNNEST(counts) AS count LIMIT 1
));

-- Helper Function: Counting Access Types
{#
  Output Schema:
  num_oa_outputs                         INTEGER NULLABLE
  num_in_doaj                            INTEGER NULLABLE
  num_green_outputs                      INTEGER NULLABLE
  num_gold_outputs                       INTEGER NULLABLE
  num_gold_just_doaj_outputs             INTEGER NULLABLE
  num_hybrid_outputs                     INTEGER NULLABLE
  num_bronze_outputs                     INTEGER NULLABLE
  num_green_only_outputs                 INTEGER NULLABLE
  num_green_only_ignoring_bronze_outputs INTEGER NULLABLE
  num_has_license                        INTEGER NULLABLE
  num_is_cclicensed                      INTEGER NULLABLE
#}
CREATE TEMP FUNCTION count_access_types(unpaywall ANY TYPE) AS ((
  SELECT AS STRUCT
    COUNTIF(is_oa                     ) AS num_oa_outputs,
    COUNTIF(is_in_doaj                ) AS num_in_doaj,
    COUNTIF(green                     ) AS num_green_outputs,
    COUNTIF(gold                      ) AS num_gold_outputs,
    COUNTIF(gold_just_doaj            ) AS num_gold_just_doaj_outputs,
    COUNTIF(hybrid                    ) AS num_hybrid_outputs,
    COUNTIF(bronze                    ) AS num_bronze_outputs,
    COUNTIF(green_only                ) AS num_green_only_outputs,
    COUNTIF(green_only_ignoring_bronze) AS num_green_only_ignoring_bronze_outputs,
    COUNTIF(has_license               ) AS num_has_license,
    COUNTIF(is_cclicensed             ) AS num_is_cclicensed
  FROM UNNEST(unpaywall)
));

-- Helper Function: Count distribution of access types and citations for a single output type
{#
  Output Schema:
  output_type                              STRING  NULLABLE
  total_outputs                            INTEGER NULLABLE
  num_oa_outputs                           INTEGER NULLABLE
  num_green_outputs                        INTEGER NULLABLE
  num_gold_outputs                         INTEGER NULLABLE
  num_gold_just_doaj_outputs               INTEGER NULLABLE
  num_hybrid_outputs                       INTEGER NULLABLE
  num_bronze_outputs                       INTEGER NULLABLE
  num_green_only_outputs                   INTEGER NULLABLE
  citations                                RECORD  NULLABLE
  citations.total_openalex_citations       INTEGER NULLABLE
  citations.total_open_citations_citations INTEGER NULLABLE
  citations.total_crossref_citations       INTEGER NULLABLE
  citations.total_mag_citations            INTEGER NULLABLE
#}
CREATE TEMP FUNCTION count_single_output_type(
  output_type        STRING,
  items              ARRAY<STRUCT<
    type               STRING,
    citations          STRUCT<
      openalex           INT64,
      crossref           INT64,
      open_citations     INT64,
      mag                INT64
    >,
    oa                 BOOL,
    green              BOOL,
    gold               BOOL,
    gold_just_doaj     BOOL,
    hybrid             BOOL,
    bronze             BOOL,
    green_only         BOOL
  >>,
  measured_type      STRING
) AS ((
  SELECT AS STRUCT
    output_type                                                 AS output_type,
    COUNTIF(item.type = measured_type                         ) AS total_outputs,
    COUNTIF(item.type = measured_type AND item.oa             ) AS num_oa_outputs,
    COUNTIF(item.type = measured_type AND item.green          ) AS num_green_outputs,
    COUNTIF(item.type = measured_type AND item.gold           ) AS num_gold_outputs,
    COUNTIF(item.type = measured_type AND item.gold_just_doaj ) AS num_gold_just_doaj_outputs,
    COUNTIF(item.type = measured_type AND item.hybrid         ) AS num_hybrid_outputs,
    COUNTIF(item.type = measured_type AND item.bronze         ) AS num_bronze_outputs,
    COUNTIF(item.type = measured_type AND item.green_only     ) AS num_green_only_outputs,
    STRUCT(
      SUM(citations.openalex      ) AS total_openalex_citations,
      SUM(citations.open_citations) AS total_open_citations_citations,
      SUM(citations.crossref      ) AS total_crossref_citations,
      SUM(citations.mag           ) AS total_mag_citations
    )                                                           AS citations
  FROM UNNEST(items) AS item
));

-- Helper Function: Count distribution of access types, bucketing a number of individual output types into a new bucket
{#
  Output Schema:
  output_type                              STRING  NULLABLE
  total_outputs                            INTEGER NULLABLE
  num_oa_outputs                           INTEGER NULLABLE
  num_green_outputs                        INTEGER NULLABLE
  num_gold_outputs                         INTEGER NULLABLE
  num_gold_just_doaj_outputs               INTEGER NULLABLE
  num_hybrid_outputs                       INTEGER NULLABLE
  num_bronze_outputs                       INTEGER NULLABLE
  num_green_only_outputs                   INTEGER NULLABLE
  citations                                RECORD  NULLABLE
  citations.total_openalex_citations       INTEGER NULLABLE
  citations.total_open_citations_citations INTEGER NULLABLE
  citations.total_crossref_citations       INTEGER NULLABLE
  citations.total_mag_citations            INTEGER NULLABLE
#}
CREATE TEMP FUNCTION count_array_output_type(
  output_type        STRING,
  items              ARRAY<STRUCT<
    type               STRING,
    citations          STRUCT<
      openalex           INT64,
      crossref           INT64,
      open_citations     INT64,
      mag                INT64
    >,
    oa                 BOOL,
    green              BOOL,
    gold               BOOL,
    gold_just_doaj     BOOL,
    hybrid             BOOL,
    bronze             BOOL,
    green_only         BOOL
  >>,
  measured_type      ARRAY<STRING>
) AS ((
  SELECT AS STRUCT
    output_type                                                         AS output_type,
    COUNTIF(item.type IN UNNEST(measured_type)                        ) AS total_outputs,
    COUNTIF(item.type IN UNNEST(measured_type) AND item.oa            ) AS num_oa_outputs,
    COUNTIF(item.type IN UNNEST(measured_type) AND item.green         ) AS num_green_outputs,
    COUNTIF(item.type IN UNNEST(measured_type) AND item.gold          ) AS num_gold_outputs,
    COUNTIF(item.type IN UNNEST(measured_type) AND item.gold_just_doaj) AS num_gold_just_doaj_outputs,
    COUNTIF(item.type IN UNNEST(measured_type) AND item.hybrid        ) AS num_hybrid_outputs,
    COUNTIF(item.type IN UNNEST(measured_type) AND item.bronze        ) AS num_bronze_outputs,
    COUNTIF(item.type IN UNNEST(measured_type) AND item.green_only    ) AS num_green_only_outputs,
    STRUCT(
      SUM(citations.openalex)       AS total_openalex_citations,
      SUM(citations.open_citations) AS total_open_citations_citations,
      SUM(citations.crossref)       AS total_crossref_citations,
      SUM(citations.mag)            AS total_mag_citations
    )                                                                   AS citations
  FROM UNNEST(items) AS item
));

-- Helper Function: Count distribution of access types, where outputtype does not match any from a list
{#
  Output Schema:
  output_type                              STRING  NULLABLE
  total_outputs                            INTEGER NULLABLE
  num_oa_outputs                           INTEGER NULLABLE
  num_green_outputs                        INTEGER NULLABLE
  num_gold_outputs                         INTEGER NULLABLE
  num_gold_just_doaj_outputs               INTEGER NULLABLE
  num_hybrid_outputs                       INTEGER NULLABLE
  num_bronze_outputs                       INTEGER NULLABLE
  num_green_only_outputs                   INTEGER NULLABLE
  citations                                RECORD  NULLABLE
  citations.total_openalex_citations       INTEGER NULLABLE
  citations.total_open_citations_citations INTEGER NULLABLE
  citations.total_crossref_citations       INTEGER NULLABLE
  citations.total_mag_citations            INTEGER NULLABLE
#}
CREATE TEMP FUNCTION count_not_in_array_output_type(
  output_type        STRING,
  items              ARRAY<STRUCT<
    type               STRING,
    citations          STRUCT<
      openalex           INT64,
      crossref           INT64,
      open_citations     INT64,
      mag                INT64
    >,
    oa                 BOOL,
    green              BOOL,
    gold               BOOL,
    gold_just_doaj     BOOL,
    hybrid             BOOL,
    bronze             BOOL,
    green_only         BOOL
  >>,
  measured_type      ARRAY<STRING>
) AS ((
  SELECT AS STRUCT
    output_type                                                              AS output_type,
    COUNTIF(item.type NOT IN UNNEST(measured_type)                         ) AS total_outputs,
    COUNTIF(item.type NOT IN UNNEST(measured_type) AND item.oa             ) AS num_oa_outputs,
    COUNTIF(item.type NOT IN UNNEST(measured_type) AND item.green          ) AS num_green_outputs,
    COUNTIF(item.type NOT IN UNNEST(measured_type) AND item.gold           ) AS num_gold_outputs,
    COUNTIF(item.type NOT IN UNNEST(measured_type) AND item.gold_just_doaj ) AS num_gold_just_doaj_outputs,
    COUNTIF(item.type NOT IN UNNEST(measured_type) AND item.hybrid         ) AS num_hybrid_outputs,
    COUNTIF(item.type NOT IN UNNEST(measured_type) AND item.bronze         ) AS num_bronze_outputs,
    COUNTIF(item.type NOT IN UNNEST(measured_type) AND item.green_only     ) AS num_green_only_outputs,
    STRUCT(
      SUM(citations.openalex      ) AS total_openalex_citations,
      SUM(citations.open_citations) AS total_open_citations_citations,
      SUM(citations.crossref      ) AS total_crossref_citations,
      SUM(citations.mag           ) AS total_mag_citations
    )                                                                        AS citations
  FROM UNNEST(items) AS item
));

-- Helper Function: Count Output Types
{#
  Output Schema:
  output_types RECORD REPEATED

  * Each record has the same schema, and is captured in the count_* methods
#}
CREATE TEMP FUNCTION count_output_types(
  items              ARRAY<STRUCT<
    type               STRING,
    citations          STRUCT<
      openalex           INT64,
      crossref           INT64,
      open_citations     INT64,
      mag                INT64
    >,
    oa                 BOOL,
    green              BOOL,
    gold               BOOL,
    gold_just_doaj     BOOL,
    hybrid             BOOL,
    bronze             BOOL,
    green_only         BOOL
  >>
) AS ([
  count_single_output_type      ("journal_articles"   , items, 'journal-article'),
  count_array_output_type       ("book_sections"      , items, [
    'book-section',
    'book-part',
    'book-chapter'
  ]),
  count_array_output_type       ("authored_books"     , items, [
    'book',
    'monograph'
  ]),
  count_single_output_type      ("edited_volumes"     , items, 'edited-book'),
  count_single_output_type      ("reports"            , items, 'report'),
  count_single_output_type      ("datasets"           , items, 'dataset'),
  count_single_output_type      ("proceedings_article", items, 'proceedings-article'),
  count_not_in_array_output_type("other_outputs"      , items, [
    'journal-article',
    'book-section',
    'book-part',
    'book-chapter',
    'book',
    'monograph',
    'edited-book',
    'report',
    'dataset',
    'proceedings-article'
  ])
]);

-- Helper Function: Compute Citation Analysis
{#
  Output Schema:
  label                                    STRING  NULLABLE
  access_type                              STRING  NULLABLE
  status                                   BOOLEAN NULLABLE
  total_outputs                            INTEGER NULLABLE
  outputs_with_citations                   INTEGER NULLABLE
  outputs_without_citations                INTEGER NULLABLE
  citations                                RECORD  NULLABLE
  citations.openalex                       RECORD  NULLABLE
  citations.openalex.total_citations       INTEGER NULLABLE
  citations.openalex.percentiles           RECORD  NULLABLE
  citations.open_citations                 RECORD  NULLABLE
  citations.open_citations.total_citations INTEGER NULLABLE
  citations.open_citations.percentiles     RECORD  NULLABLE
  citations.crossref                       RECORD  NULLABLE
  citations.crossref.total_citations       INTEGER NULLABLE
  citations.crossref.percentiles           RECORD  NULLABLE
  citations.mag                            RECORD  NULLABLE
  citations.mag.total_citations            INTEGER NULLABLE
  citations.mag.percentiles                RECORD  NULLABLE

  *percentiles schema captured above
#}
CREATE TEMP FUNCTION compute_conditional_citations(
  items               ARRAY<STRUCT<
    citations           STRUCT<
      openalex            INT64,
      crossref            INT64,
      open_citations      INT64,
      mag                 INT64
    >,
    is_x                BOOL
  >>,
  access_type         STRING,
  positive_label      STRING,
  negative_label      STRING
) AS (ARRAY(
  SELECT AS STRUCT
    IF (is_x,
      positive_label,
      negative_label
    )                                                           AS label,
    access_type                                                 AS access_type,
    is_x                                                        AS `status`,
    COUNT(*)                                                    AS total_outputs,
    COUNTIF(
      citations.crossref       > 0 OR
      citations.open_citations > 0 OR
      citations.openalex       > 0 OR
      citations.mag            > 0
    )                                                           AS outputs_with_citations,
    COUNTIF(
      (citations.crossref       IS NULL OR citations.crossref       = 0) AND
      (citations.open_citations IS NULL OR citations.open_citations = 0) AND
      (citations.openalex       IS NULL OR citations.openalex       = 0) OR
      (citations.mag            IS NULL OR citations.mag            = 0)
    )                                                           AS outputs_without_citations,
    STRUCT(
      STRUCT(
        SUM(citations.openalex)                                     AS total_citations,
        compute_percentiles(ARRAY_AGG(citations.openalex))          AS percentiles
      )                                                           AS openalex,
      STRUCT(
        SUM(citations.open_citations)                               AS total_citations,
        compute_percentiles(ARRAY_AGG(citations.open_citations))    AS percentiles
      )                                                           AS open_citations,
      STRUCT(
        SUM(citations.crossref)                                     AS total_citations, 
        compute_percentiles(ARRAY_AGG(citations.crossref))          AS percentiles
      )                                                           AS crossref,
      STRUCT(
        SUM(citations.mag)                                          AS total_citations,
        compute_percentiles(ARRAY_AGG(citations.mag))               AS percentiles
      )                                                           AS mag
    )                                                           AS citations
  FROM UNNEST(items)
  GROUP BY is_x
));

-- Helper Function: Compute a citation analysis across the array of passed in objects
{#
  Output Schema:
  openalex                                   RECORD  NULLABLE
  openalex.total_citations                   INTEGER NULLABLE
  openalex.citations_per_output              FLOAT   NULLABLE
  openalex.outputs_with_citations            INTEGER NULLABLE
  openalex.outputs_without_citations         INTEGER NULLABLE
  openalex.citations_per_cited_output        FLOAT   NULLABLE
  crossref                                   RECORD  NULLABLE
  crossref.total_citations                   INTEGER NULLABLE
  crossref.citations_per_output              FLOAT   NULLABLE
  crossref.outputs_with_citations            INTEGER NULLABLE
  crossref.outputs_without_citations         INTEGER NULLABLE
  crossref.citations_per_cited_output        FLOAT   NULLABLE
  open_citations                             RECORD  NULLABLE
  open_citations.total_citations             INTEGER NULLABLE
  open_citations.citations_per_output        FLOAT   NULLABLE
  open_citations.outputs_with_citations      INTEGER NULLABLE
  open_citations.outputs_without_citations   INTEGER NULLABLE
  open_citations.citations_per_cited_output  FLOAT   NULLABLE
  mag                                        RECORD  NULLABLE
  mag.total_citations                        INTEGER NULLABLE
  mag.citations_per_output                   FLOAT   NULLABLE
  mag.outputs_with_citations                 INTEGER NULLABLE
  mag.outputs_without_citations              INTEGER NULLABLE
  mag.citations_per_cited_output             FLOAT   NULLABLE
#}
CREATE TEMP FUNCTION compute_citations(
  items              ARRAY<STRUCT<
    doi               STRING,
    citations         STRUCT<
      openalex          INT64,
      crossref          INT64,
      open_citations    INT64,
      mag               INT64
    >
  >>
) AS ((
  SELECT AS STRUCT
    -- Citation counts
    STRUCT(
      SUM(citations.openalex      )                                                               AS total_citations,
      ROUND(SAFE_DIVIDE(SUM(citations.openalex      ), COUNT(doi)), 2)                            AS citations_per_output,
      COUNTIF(citations.openalex       > 0)                                                       AS outputs_with_citations,
      COUNTIF(citations.openalex       IS NULL)                                                   AS outputs_without_citations,
      ROUND(SAFE_DIVIDE(SUM(citations.openalex      ), COUNTIF(citations.openalex       > 0)), 2) AS citations_per_cited_output
    ) AS openalex,
    STRUCT(
      SUM(citations.crossref      )                                                               AS total_citations,
      ROUND(SAFE_DIVIDE(SUM(citations.crossref      ), COUNT(doi)), 2)                            AS citations_per_output,
      COUNTIF(citations.crossref       > 0)                                                       AS outputs_with_citations,
      COUNTIF(citations.crossref       IS NULL)                                                   AS outputs_without_citations,
      ROUND(SAFE_DIVIDE(SUM(citations.crossref      ), COUNTIF(citations.crossref       > 0)), 2) AS citations_per_cited_output
    ) AS crossref,
    STRUCT(
      SUM(citations.open_citations)                                                               AS total_citations,
      ROUND(SAFE_DIVIDE(SUM(citations.open_citations), COUNT(doi)), 2)                            AS citations_per_output,
      COUNTIF(citations.open_citations > 0)                                                       AS outputs_with_citations,
      COUNTIF(citations.open_citations IS NULL)                                                   AS outputs_without_citations,
      ROUND(SAFE_DIVIDE(SUM(citations.open_citations), COUNTIF(citations.open_citations > 0)), 2) AS citations_per_cited_output
    ) AS open_citations,
    STRUCT(
      SUM(citations.mag           )                                                               AS total_citations,
      ROUND(SAFE_DIVIDE(SUM(citations.mag           ), COUNT(doi)), 2)                            AS citations_per_output,
      COUNTIF(citations.mag            > 0)                                                       AS outputs_with_citations,
      COUNTIF(citations.mag            IS NULL)                                                   AS outputs_without_citations,
      ROUND(SAFE_DIVIDE(SUM(citations.mag           ), COUNTIF(citations.mag            > 0)), 2) AS citations_per_cited_output
    ) AS mag
  FROM UNNEST(items)
));

-- Helper Function: Compute the count of various Open Access Types from a passed in array of Objects
{#
  Output Schema:
  oa                       RECORD  NULLABLE
  oa.total_outputs         INTEGER NULLABLE
  oa.percent               FLOAT   NULLABLE
  green                    RECORD  NULLABLE
  green.total_outputs      INTEGER NULLABLE
  green.percent            FLOAT   NULLABLE
  gold                     RECORD  NULLABLE
  gold.total_outputs       INTEGER NULLABLE
  gold.percent             FLOAT   NULLABLE
  gold_doaj                RECORD  NULLABLE
  gold_doaj.total_outputs  INTEGER NULLABLE
  gold_doaj.percent        FLOAT   NULLABLE
  hybrid                   RECORD  NULLABLE
  hybrid.total_outputs     INTEGER NULLABLE
  hybrid.percent           FLOAT   NULLABLE
  bronze                   RECORD  NULLABLE
  bronze.total_outputs     INTEGER NULLABLE
  bronze.percent           FLOAT   NULLABLE
  green_only               RECORD  NULLABLE
  green_only.total_outputs INTEGER NULLABLE
  green_only.percent       FLOAT   NULLABLE
  breakdown                RECORD  REPEATED

  * breakdown object array captured in compute_conditional_citations schema above
#}
CREATE TEMP FUNCTION compute_access_types(
  items               ARRAY<STRUCT<
    doi                 STRING,
    citations           STRUCT<
      openalex            INT64,
      crossref            INT64,
      open_citations      INT64,
      mag                 INT64
    >,
    is_oa               BOOL,
    green               BOOL,
    gold                BOOL,
    gold_just_doaj      BOOL,
    hybrid              BOOL,
    bronze              BOOL,
    green_only          BOOL
  >>
) AS ((
  SELECT AS STRUCT
    STRUCT(COUNTIF(is_oa         ) AS total_outputs, ROUND(SAFE_DIVIDE((COUNTIF(is_oa         )) * 100, COUNT(doi)), 2) AS percent) AS oa,
    STRUCT(COUNTIF(green         ) AS total_outputs, ROUND(SAFE_DIVIDE((COUNTIF(green         )) * 100, COUNT(doi)), 2) AS percent) AS green,
    STRUCT(COUNTIF(gold          ) AS total_outputs, ROUND(SAFE_DIVIDE((COUNTIF(gold          )) * 100, COUNT(doi)), 2) AS percent) AS gold,
    STRUCT(COUNTIF(gold_just_doaj) AS total_outputs, ROUND(SAFE_DIVIDE((COUNTIF(gold_just_doaj)) * 100, COUNT(doi)), 2) AS percent) AS gold_doaj,
    STRUCT(COUNTIF(hybrid        ) AS total_outputs, ROUND(SAFE_DIVIDE((COUNTIF(hybrid        )) * 100, COUNT(doi)), 2) AS percent) AS hybrid,
    STRUCT(COUNTIF(bronze        ) AS total_outputs, ROUND(SAFE_DIVIDE((COUNTIF(bronze        )) * 100, COUNT(doi)), 2) AS percent) AS bronze,
    STRUCT(COUNTIF(green_only    ) AS total_outputs, ROUND(SAFE_DIVIDE((COUNTIF(green_only    )) * 100, COUNT(doi)), 2) AS percent) AS green_only,
    ARRAY_CONCAT(
      compute_conditional_citations(ARRAY_AGG(STRUCT(citations, IFNULL(is_oa         , FALSE) AS is_x)), "oa"            , "Open Access"   , "Not Open Access"   ),
      compute_conditional_citations(ARRAY_AGG(STRUCT(citations, IFNULL(green         , FALSE) AS is_x)), "green"         , "Green"         , "Not Green"         ),
      compute_conditional_citations(ARRAY_AGG(STRUCT(citations, IFNULL(gold          , FALSE) AS is_x)), "gold"          , "Gold"          , "Not Gold"          ),
      compute_conditional_citations(ARRAY_AGG(STRUCT(citations, IFNULL(gold_just_doaj, FALSE) AS is_x)), "gold_just_doaj", "Gold just DOAJ", "Not Gold just DOAJ"),
      compute_conditional_citations(ARRAY_AGG(STRUCT(citations, IFNULL(hybrid        , FALSE) AS is_x)), "hybrid"        , "Hybrid"        , "Not Hybrid"        ),
      compute_conditional_citations(ARRAY_AGG(STRUCT(citations, IFNULL(bronze        , FALSE) AS is_x)), "bronze"        , "Bronze"        , "Not Bronze"        ),
      compute_conditional_citations(ARRAY_AGG(STRUCT(citations, IFNULL(green_only    , FALSE) AS is_x)), "green_only"    , "Green Only"    , "Not Green Only"    )
    )                                                                                                                               AS breakdown
  FROM UNNEST(items)
));

-- Helper Function: compute COKI Open Access categories
CREATE TEMP FUNCTION compute_coki_oa(
  items                         ARRAY<STRUCT<
    doi                           STRING,
    oa_coki                       STRUCT<
      open                          BOOL,
      closed                        BOOL,
      publisher                     BOOL,
      other_platform                BOOL,
      publisher_only                BOOL,
      both                          BOOL,
      other_platform_only           BOOL,
      publisher_categories          STRUCT<
        oa_journal                    BOOL,
        hybrid                        BOOL,
        no_guarantees                 BOOL
      >,
      other_platform_categories     STRUCT<
        preprint                      BOOL,
        domain                        BOOL,
        institution                   BOOL,
        public                        BOOL,
        aggregator                    BOOL,
        other_internet                BOOL,
        unknown                       BOOL
      >
    >
  >>
) AS ((
  SELECT AS STRUCT
    STRUCT(COUNTIF(oa_coki.open                = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.open                IS TRUE)) * 100, COUNT(doi)), 2) AS percent) AS open,
    STRUCT(COUNTIF(oa_coki.closed              = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.closed              IS TRUE)) * 100, COUNT(doi)), 2) AS percent) AS closed,
    STRUCT(COUNTIF(oa_coki.publisher           = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.publisher           IS TRUE)) * 100, COUNT(doi)), 2) AS percent) AS publisher,
    STRUCT(COUNTIF(oa_coki.other_platform      = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.other_platform      IS TRUE)) * 100, COUNT(doi)), 2) AS percent) AS other_platform,
    STRUCT(COUNTIF(oa_coki.publisher_only      = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.publisher_only      IS TRUE)) * 100, COUNT(doi)), 2) AS percent) AS publisher_only,
    STRUCT(COUNTIF(oa_coki.both                = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.both                IS TRUE)) * 100, COUNT(doi)), 2) AS percent) AS both,
    STRUCT(COUNTIF(oa_coki.other_platform_only = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.other_platform_only IS TRUE)) * 100, COUNT(doi)), 2) AS percent) AS other_platform_only,
    STRUCT(
      STRUCT(COUNTIF(oa_coki.publisher_categories.oa_journal          = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.publisher_categories.oa_journal          IS TRUE)) * 100, COUNTIF(oa_coki.publisher      = TRUE)), 2) AS percent) AS oa_journal,
      STRUCT(COUNTIF(oa_coki.publisher_categories.hybrid              = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.publisher_categories.hybrid              IS TRUE)) * 100, COUNTIF(oa_coki.publisher      = TRUE)), 2) AS percent) AS hybrid,
      STRUCT(COUNTIF(oa_coki.publisher_categories.no_guarantees       = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.publisher_categories.no_guarantees       IS TRUE)) * 100, COUNTIF(oa_coki.publisher      = TRUE)), 2) AS percent) AS no_guarantees
    )                                                                                                                                                                AS publisher_categories,
    STRUCT(
      STRUCT(COUNTIF(oa_coki.other_platform_categories.preprint       = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.other_platform_categories.preprint       IS TRUE)) * 100, COUNTIF(oa_coki.other_platform = TRUE)), 2) AS percent) AS preprint,
      STRUCT(COUNTIF(oa_coki.other_platform_categories.domain         = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.other_platform_categories.domain         IS TRUE)) * 100, COUNTIF(oa_coki.other_platform = TRUE)), 2) AS percent) AS domain,
      STRUCT(COUNTIF(oa_coki.other_platform_categories.institution    = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.other_platform_categories.institution    IS TRUE)) * 100, COUNTIF(oa_coki.other_platform = TRUE)), 2) AS percent) AS institution,
      STRUCT(COUNTIF(oa_coki.other_platform_categories.public         = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.other_platform_categories.public         IS TRUE)) * 100, COUNTIF(oa_coki.other_platform = TRUE)), 2) AS percent) AS public,
      STRUCT(COUNTIF(oa_coki.other_platform_categories.aggregator     = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.other_platform_categories.aggregator     IS TRUE)) * 100, COUNTIF(oa_coki.other_platform = TRUE)), 2) AS percent) AS aggregator,
      STRUCT(COUNTIF(oa_coki.other_platform_categories.other_internet = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.other_platform_categories.other_internet IS TRUE)) * 100, COUNTIF(oa_coki.other_platform = TRUE)), 2) AS percent) AS other_internet,
      STRUCT(COUNTIF(oa_coki.other_platform_categories.unknown        = TRUE) AS total, ROUND(SAFE_DIVIDE((COUNTIF(oa_coki.other_platform_categories.unknown        IS TRUE)) * 100, COUNTIF(oa_coki.other_platform = TRUE)), 2) AS percent) AS unknown
    )                                                                                                                                                                AS other_platform_categories
  FROM UNNEST(items)
));

-- Helper Function:  Compute summary statistic, grouped by a field of study for an array of passed in items
{#
  Output Schema:
  field                                            STRING  NULLABLE
  total_outputs                                    INTEGER NULLABLE
  sum_of_scores                                    FLOAT   NULLABLE
  citations                                        RECORD  NULLABLE
  openalex                                         RECORD  NULLABLE
  total_citations                                  INTEGER NULLABLE
  percentiles                                      RECORD  NULLABLE
  open_citations                                   RECORD  NULLABLE
  total_citations                                  INTEGER NULLABLE
  percentiles                                      RECORD  NULLABLE
  crossref                                         RECORD  NULLABLE
  total_citations                                  INTEGER NULLABLE
  percentiles                                      RECORD  NULLABLE
  mag                                              RECORD  NULLABLE
  total_citations                                  INTEGER NULLABLE
  percentiles                                      RECORD  NULLABLE
  num_oa_outputs                                   INTEGER NULLABLE
  num_green_outputs                                INTEGER NULLABLE
  num_gold_outputs                                 INTEGER NULLABLE
  num_gold_just_doaj_outputs                       INTEGER NULLABLE
  num_hybrid_outputs                               INTEGER NULLABLE
  num_bronze_outputs                               INTEGER NULLABLE
  num_green_only_outputs                           INTEGER NULLABLE
  funding                                          RECORD  NULLABLE
  total_funded_outputs                             INTEGER NULLABLE
  num_international_outputs                        INTEGER NULLABLE
  num_domestic_outputs                             INTEGER NULLABLE
  num_international_and_domestic_outputs           INTEGER NULLABLE
  num_government_outputs                           INTEGER NULLABLE
  num_private_outputs                              INTEGER NULLABLE
  num_government_and_private_outputs               INTEGER NULLABLE
  num_international_collaboration_outputs          INTEGER NULLABLE
  international_collaboration_with_funding_outputs INTEGER NULLABLE
#}
CREATE TEMP FUNCTION compute_disciplines(
  fields                  ARRAY<STRUCT<
    DisplayName             STRING,
    Score                   FLOAT64,
    citations               STRUCT<
      openalex                INT64,
      crossref                INT64,
      open_citations          INT64,
      mag                     INT64
    >,
    is_oa                   BOOL,
    green                   BOOL,
    gold                    BOOL,
    gold_just_doaj          BOOL,
    hybrid                  BOOL,
    bronze                  BOOL,
    green_only              BOOL,
    funding                 BOOL,
    international_funding   BOOL,
    domestic_funding        BOOL,
    government_funding      BOOL,
    private_funding         BOOL,
    international_colab     BOOL
  >>
) AS (ARRAY((
  SELECT AS STRUCT
    DisplayName                  AS field,
    COUNT(DisplayName)           AS total_outputs,
    SUM(Score)                   AS sum_of_scores,
    STRUCT(
      STRUCT(SUM(citations.mag           ) AS total_citations, compute_percentiles(ARRAY_AGG(citations.mag           )) AS percentiles) AS mag,
      STRUCT(SUM(citations.openalex      ) AS total_citations, compute_percentiles(ARRAY_AGG(citations.openalex      )) AS percentiles) AS openalex,
      STRUCT(SUM(citations.open_citations) AS total_citations, compute_percentiles(ARRAY_AGG(citations.open_citations)) AS percentiles) AS open_citations,
      STRUCT(SUM(citations.crossref      ) AS total_citations, compute_percentiles(ARRAY_AGG(citations.crossref      )) AS percentiles) AS crossref
    )                            AS citations,
    COUNTIF(is_oa)               AS num_oa_outputs,
    COUNTIF(green)               AS num_green_outputs,
    COUNTIF(gold)                AS num_gold_outputs,
    COUNTIF(gold_just_doaj)      AS num_gold_just_doaj_outputs,
    COUNTIF(hybrid)              AS num_hybrid_outputs,
    COUNTIF(bronze)              AS num_bronze_outputs,
    COUNTIF(green_only)          AS num_green_only_outputs,
    STRUCT(
      COUNTIF(funding              ) AS total_funded_outputs,
      COUNTIF(international_funding) AS num_international_outputs,
      COUNTIF(domestic_funding     ) AS num_domestic_outputs,
      COUNTIF(
        international_funding AND domestic_funding
      )                              AS num_international_and_domestic_outputs,
      COUNTIF(government_funding   ) AS num_government_outputs,
      COUNTIF(private_funding      ) AS num_private_outputs,
      COUNTIF(
        government_funding AND private_funding
      )                              AS num_government_and_private_outputs
    )                            AS funding,
    COUNTIF(international_colab) AS num_international_collaboration_outputs,
    COUNTIF(
      international_colab AND international_funding
    )                            AS international_collaboration_with_funding_outputs
  FROM UNNEST(fields)
  GROUP BY DisplayName
)));

-- Helper Function: Function to help with the process_relations function below. Simlifed summary, grouped by field of study
{#
  Output Schema:
  field           STRING NULLABLE
  total_outputs   INTEGER NULLABLE
  num_oa_outputs INTEGER NULLABLE
  sum_of_scores   FLOAT NULLABLE
#}
CREATE TEMP FUNCTION group_disciplines(
  fields        ARRAY<STRUCT<
    DisplayName   STRING,
    Score         FLOAT64,
    is_oa         BOOL
  >>
) AS (ARRAY((
  SELECT AS STRUCT
    DisplayName          AS field,
    COUNT(DisplayName)   AS total_outputs,
    COUNTIF(is_oa)       AS num_oa_outputs,
    ROUND(SUM(Score), 4) AS sum_of_scores
  FROM UNNEST(fields)
  GROUP BY DisplayName
)));

-- Helper Function: Compute a summary of OA types, citations and fields of study. Use for compute collaborations and various other relationship to the primary entity
{#
  Output Schema:
  id                                     STRING  NULLABLE
  total_outputs                          INTEGER NULLABLE
  percentage_of_all_outputs              FLOAT   NULLABLE
  percentage_of_all_oa                   FLOAT   NULLABLE
  name                                   STRING  NULLABLE
  country                                STRING  NULLABLE
  country_code                           STRING  NULLABLE
  region                                 STRING  NULLABLE
  subregion                              STRING  NULLABLE
  coordinates                            STRING  NULLABLE
  num_oa_outputs                         INTEGER NULLABLE
  num_in_doaj                            INTEGER NULLABLE
  num_green_outputs                      INTEGER NULLABLE
  num_gold_outputs                       INTEGER NULLABLE
  num_gold_just_doaj_outputs             INTEGER NULLABLE
  num_hybrid_outputs                     INTEGER NULLABLE
  num_bronze_outputs                     INTEGER NULLABLE
  num_green_only_outputs                 INTEGER NULLABLE
  num_green_only_ignoring_bronze_outputs INTEGER NULLABLE
  num_has_license                        INTEGER NULLABLE
  num_is_cclicensed                      INTEGER NULLABLE
  citations                              RECORD  NULLABLE
  citations.openalex                     INTEGER NULLABLE
  citations.crossref                     INTEGER NULLABLE
  citations.open_citations               INTEGER NULLABLE
  citations.mag                          INTEGER NULLABLE
  disciplines                            RECORD  REPEATED

  * Schema for disciplines captured above
#}
CREATE TEMP FUNCTION process_relations(
  relationships ANY TYPE,
  total         INT64,
  total_oa      INT64
) AS (ARRAY(
  SELECT AS STRUCT
    relation.identifier                                           AS id,
    COUNT(relation.identifier)                                    AS total_outputs,
    ROUND(SAFE_DIVIDE(COUNT  (relation.identifier), total   ), 3) AS percentage_of_all_outputs,
    ROUND(SAFE_DIVIDE(COUNTIF(unpaywall.is_oa    ), total_oa), 3) AS percentage_of_all_oa,
    MAX(relation.name        )                                    AS name,
    MAX(relation.country     )                                    AS country,
    MAX(relation.country_code)                                    AS country_code,
    MAX(relation.region      )                                    AS region,
    MAX(relation.subregion   )                                    AS subregion,
    MAX(relation.coordinates )                                    AS coordinates,
    count_access_types(ARRAY_AGG(unpaywall)).*,
    STRUCT(
      SUM(citations.openalex)       AS openalex,
      SUM(citations.crossref)       AS crossref,
      SUM(citations.open_citations) AS open_citations,
      SUM(citations.mag)            AS mag
    )                                                             AS citations,
    group_disciplines(ARRAY_CONCAT_AGG(disciplines))              AS disciplines
  FROM UNNEST(relationships) AS relation
  GROUP BY relation.identifier
  ORDER BY total_outputs DESC
  LIMIT 1000
));

-- Helper Function: Create a summary of events, grouped into the event type
{#
  Output Schema:
  source                     STRING  NULLABLE
  total_outputs              INTEGER NULLABLE
  num_oa_outputs             INTEGER NULLABLE
  num_green_outputs          INTEGER NULLABLE
  num_gold_outputs           INTEGER NULLABLE
  num_gold_just_doaj_outputs INTEGER NULLABLE
  num_hybrid_outputs         INTEGER NULLABLE
  num_bronze_outputs         INTEGER NULLABLE
  num_green_only_outputs     INTEGER NULLABLE
#}
CREATE TEMP FUNCTION process_events(events ANY TYPE) AS (ARRAY(
  SELECT AS STRUCT
    source                             AS source,
    SUM(                   count     ) AS total_outputs,
    SUM(IF(is_oa         , count, 0) ) AS num_oa_outputs,
    SUM(IF(green         , count, 0) ) AS num_green_outputs,
    SUM(IF(gold          , count, 0) ) AS num_gold_outputs,
    SUM(IF(gold_just_doaj, count, 0) ) AS num_gold_just_doaj_outputs,
    SUM(IF(hybrid        , count, 0) ) AS num_hybrid_outputs,
    SUM(IF(bronze        , count, 0) ) AS num_bronze_outputs,
    SUM(IF(green_only    , count, 0) ) AS num_green_only_outputs
  FROM UNNEST(events)
  GROUP BY source
  ORDER BY total_outputs DESC
));

-- Helper Function: Creates a summary count for how many objects where hosted at a given repository
{#
  Output Schema:
  id                      STRING  NULLABLE
  total_outputs           INTEGER NULLABLE
  percentage_of_all_green FLOAT   NULLABLE
#}
CREATE TEMP FUNCTION process_repositories(
  repositories              ARRAY<STRUCT<
    coki_repository_name      STRING,
    endpoint_id               STRING,
    repository_institution    STRING,
    pmh_domain                STRING,
    pmh_id                    STRING,
    url                       STRING,
    category                  STRING,
    rors                      ARRAY<STRUCT<
      id                        STRING,
      name                      STRING
    >>
  >>,
  ror_id       STRING
) AS (ARRAY(
  SELECT AS STRUCT
    id,
    total_outputs,
    category,
    ror_id IN (
      SELECT id FROM UNNEST(rors_agg) WHERE id IS NOT NULL GROUP BY id
    )             AS home_repo
  FROM (
    SELECT AS STRUCT
      coki_repository_name    AS id,
      COUNT(repository)       AS total_outputs,
      MAX(category)           AS category,
      ARRAY_CONCAT_AGG(rors)  AS rors_agg
    FROM UNNEST(repositories) AS repository
    WHERE coki_repository_name IS NOT NULL
    GROUP BY coki_repository_name
    ORDER BY total_outputs DESC, LOWER(id) ASC
  )
));

----
-- Main SQL Function
----

{#
  The key thing to understand about the logic below is all about building input that is passed into the compute_disciplines function

  This whole block of SQL lives inside the 'GROUP BY aggregrate.identifier, crossref.{{ group_by_time_field }}' so it must include an aggregation
  The ARRAY_CONCAT_AGG performs this task. The reason it is not just an ARRAY_AGG, is because it is aggregrating multiple arrays,
  These are each created from 'UNNEST(openalex.concepts) as fields where fields.level = 0'

  Ultimately, what is passed into the compute_disciplines function is an array of STRUCTS, with each struct keyed off an individual fieldName
#}
WITH
-- Discipline.  This will be merged with the tmp_agg_table.
tmp_disciplines AS (
  SELECT
    aggregrate.identifier                   AS id,
    dois.crossref.{{ group_by_time_field }} AS time_period,
    STRUCT(
      compute_disciplines(ARRAY_CONCAT_AGG(ARRAY((
        SELECT AS STRUCT
          fields.display_name      AS DisplayName,
          fields.Score             AS Score,
          STRUCT(
            dois.openalex.cited_by_count        AS openalex,
            dois.crossref.references_count      AS crossref,
            dois.open_citations.citations_total AS open_citations,
            dois.mag.CitationCount              AS mag
          )                        AS citations,
          unpaywall.is_oa          AS is_oa,
          unpaywall.green          AS green,
          unpaywall.gold           AS gold,
          unpaywall.gold_just_doaj AS gold_just_doaj,
          unpaywall.hybrid         AS hybrid,
          unpaywall.bronze         AS bronze,
          unpaywall.green_only     AS green_only,
          (SELECT COUNT(funder) > 0 FROM UNNEST(affiliations.funders  ) AS funder                                                       ) AS funding              , -- Total Funding
          (SELECT COUNT(funder) > 0 FROM UNNEST(affiliations.funders  ) AS funder WHERE funder.country_code <> aggregrate.country_code_2) AS international_funding, -- Domestic, international, both, none or unknown funding
          (SELECT COUNT(funder) > 1 FROM UNNEST(affiliations.funders  ) AS funder WHERE funder.country_code = aggregrate.country_code_2 ) AS domestic_funding     , -- Domestic, international, both, none or unknown funding
          (SELECT COUNT(funder) > 0 FROM UNNEST(affiliations.funders  ) AS funder WHERE funder.funding_body_subtype = 'gov'             ) AS government_funding   , -- Has Industry or Government or both funding
          (SELECT COUNT(funder) > 0 FROM UNNEST(affiliations.funders  ) AS funder WHERE funder.funding_body_subtype = 'pri'             ) AS private_funding      , -- Has Industry or Government or both funding
          (SELECT COUNT(collab) > 0 FROM UNNEST(affiliations.countries) AS collab WHERE collab.country <> aggregrate.country            ) AS international_collab   -- Domestic collaboration only or international collaboration or single institution only
        FROM UNNEST(openalex.concepts) AS fields WHERE fields.level = 0)) )) AS level0
    )                                       AS disciplines
  FROM
    `{{ project_id }}.{{ dataset_id }}.doi{{ release_date.strftime('%Y%m%d') }}` AS dois,
    UNNEST(dois.affiliations.{{ aggregation_field }})                            AS aggregrate
  WHERE aggregrate.identifier IS NOT NULL
  GROUP BY aggregrate.identifier, crossref.{{ group_by_time_field }}
),

-- Access Types.  This will be merged with the tmp_agg_table.
tmp_access_types AS (
  SELECT
    aggregrate.identifier                   AS id,
    dois.crossref.{{ group_by_time_field }} AS time_period,
    compute_access_types(ARRAY_AGG(STRUCT(
      dois.doi                 AS doi,
      STRUCT(
        dois.openalex.cited_by_count        AS openalex,
        dois.crossref.references_count      AS crossref,
        dois.open_citations.citations_total AS open_citations,
        dois.mag.CitationCount              AS mag
      )                        AS citations,
      unpaywall.is_oa          AS is_oa,
      unpaywall.green          AS green,
      unpaywall.gold           AS gold,
      unpaywall.gold_just_doaj AS gold_just_doaj,
      unpaywall.hybrid         AS hybrid,
      unpaywall.bronze         AS bronze,
      unpaywall.green_only     AS green_only
    )))                                     AS access_types
  FROM
    `{{ project_id }}.{{ dataset_id }}.doi{{ release_date.strftime('%Y%m%d') }}` AS dois,
    UNNEST(dois.affiliations.{{ aggregation_field }})                            AS aggregrate
  WHERE aggregrate.identifier IS NOT NULL
  GROUP BY aggregrate.identifier, crossref.{{ group_by_time_field }}
),

-- Base aggregations. Will be extended by other columns during final merge.
tmp_agg_table AS (
  SELECT
    -- Common Metadata
    aggregrate.identifier                   AS id,
    dois.crossref.{{ group_by_time_field }} AS time_period,
    MAX(aggregrate.name           )         AS name,
    MAX(aggregrate.country        )         AS country,
    MAX(aggregrate.country_code   )         AS country_code,
    MAX(aggregrate.country_code_2 )         AS country_code_2,
    MAX(aggregrate.region         )         AS region,
    MAX(aggregrate.subregion      )         AS subregion,
    MAX(aggregrate.coordinates    )         AS coordinates,

    -- Total outputs
    COUNT(dois.doi)                         AS total_outputs,

    -- COKI OA
    compute_coki_oa(ARRAY_AGG(STRUCT(
      dois.doi,
      coki.oa_coki
    )))                                     AS oa_coki,

    -- Citations
    compute_citations(ARRAY_AGG(STRUCT(
      dois.doi,
      STRUCT(
        dois.openalex.cited_by_count        AS openalex,
        dois.crossref.references_count      AS crossref,
        dois.open_citations.citations_total AS open_citations,
        dois.mag.CitationCount              AS mag
      ) AS citations
    )))                                     AS citations,

    -- Output Types
    count_output_types(ARRAY_AGG(STRUCT(
      unpaywall.output_type,
      STRUCT(
        dois.openalex.cited_by_count        AS openalex,
        dois.crossref.references_count      AS crossref,
        dois.open_citations.citations_total AS open_citations,
        dois.mag.CItationCount              AS mag
      )           AS citations,
      unpaywall.is_oa,
      unpaywall.green,
      unpaywall.gold,
      unpaywall.gold_just_doaj,
      unpaywall.hybrid,
      unpaywall.bronze,
      unpaywall.green_only
    )))                                     AS output_types,

    -- Repositories
    {#
      This SQL block aggregrates the repository names, remembering we are inside a larger GROUP BY statement,
    #}
    process_repositories(
      ARRAY_CONCAT_AGG(coki.repositories),
      MAX(aggregrate.identifier)
    )                                       AS repositories,

    {% if relate_to_institutions %}
    -- Institutions
    {#
      This SQL block UNNESTS the 'UNNEST(affiliations.institutions)' section of the DOI table. By doing this, it creates a new rows for each institution listed
      The WHERE statement 'relation.identifier <> aggregrate.identifier' ignores the identifer that is the subject of the overall GROUP BY statement
      The aggregrate.identifer is only relevant where this is creating the institutions table, as this code is used to create a range of dervied tables

      The end goal is to pass on a list of objects to the process_relations function, which is able to compute summaries for each identified insitution
    #}
    process_relations(
      ARRAY_CONCAT_AGG(ARRAY((
        SELECT AS STRUCT
          relation  AS relation,
          unpaywall AS unpaywall,
          STRUCT(
            dois.openalex.cited_by_count        AS openalex,
            dois.crossref.references_count      AS crossref,
            dois.open_citations.citations_total AS open_citations,
            dois.mag.CitationCount              AS mag
          )         AS citations,
          ARRAY(
            SELECT as STRUCT
              display_name    AS DisplayName,
              Score           AS Score,
              unpaywall.is_oa AS is_oa
            FROM UNNEST(openalex.concepts) AS field
            WHERE fields.level = 0
          )         AS disciplines
        FROM UNNEST(affiliations.institutions) AS relation
        WHERE relation.identifier <> aggregrate.identifier
      ))),
      COUNT(dois.doi),
      COUNTIF(unpaywall.is_oa = TRUE)
    )                                       AS institutions,
    {% endif %}

    {% if relate_to_countries %}
    -- Countries
    {#
      This SQL block UNNESTS the 'UNNEST(affiliations.countries)' section of the DOI table. By doing this, it creates a new rows for each country listed
      The WHERE statement 'relation.identifier <> aggregrate.identifier' ignores the identifer that is the subject of the overall GROUP BY statement
      The aggregrate.identifer is only relevant where this is creating the country table, as this code is used to create a range of dervied tables

      The end goal is to pass on a list of objects to the process_relations function, which is able to compute summaries for each country insitution
    #}
    process_relations(
      ARRAY_CONCAT_AGG(ARRAY((
        SELECT AS STRUCT
          relation,
          unpaywall,
          STRUCT(
            dois.openalex.cited_by_count        AS openalex,
            dois.crossref.references_count      AS crossref,
            dois.open_citations.citations_total AS open_citations,
            dois.mag.CitationCount              AS mag
          ) AS citations,
          ARRAY(
            SELECT AS STRUCT
              display_name    AS DisplayName,
              Score           AS Score,
              unpaywall.is_oa AS is_oa
            FROM UNNEST(openalex.concepts) AS fields
            WHERE fields.level = 0
          ) AS disciplines
        FROM UNNEST(affiliations.countries) AS relation
        WHERE relation.identifier <> aggregrate.country_code OR aggregrate.country_code IS NULL
      ))),
      COUNT(dois.doi),
      COUNTIF(unpaywall.is_oa = TRUE)
    )                                       AS countries,
    {% endif %}

    {% if relate_to_groups %}
    -- Groupings
    {#
      This SQL block UNNESTS the 'UNNEST(affiliations.groupings)' section of the DOI table. By doing this, it creates a new rows for each group listed
      The WHERE statement 'relation.identifier <> aggregrate.identifier' ignores the identifer that is the subject of the overall GROUP BY statement
      The aggregrate.identifer is only relevant where this is creating the groups table, as this code is used to create a range of dervied tables

      The end goal is to pass on a list of objects to the process_relations function, which is able to compute summaries for each identified insitution
    #}
    process_relations(
      ARRAY_CONCAT_AGG(ARRAY((
        SELECT AS STRUCT
          relation,
          unpaywall,
          STRUCT(
            dois.openalex.cited_by_count        AS openalex,
            dois.crossref.references_count      AS crossref,
            dois.open_citations.citations_total AS open_citations,
            dois.mag.CitationCount              AS mag
          )         AS citations,
          ARRAY(
            SELECT AS STRUCT
              display_name    AS DisplayName,
              Score           AS Score,
              unpaywall.is_oa AS is_oa
            FROM UNNEST(openalex.concepts) AS fields
            WHERE fields.level = 0
          )         AS disciplines
        FROM UNNEST(affiliations.groupings) AS relation
        WHERE relation.identifier <> aggregrate.identifier))
      ),
      COUNT(dois.doi),
      COUNTIF(unpaywall.is_oa = TRUE)
    )                                       AS groupings,
    {% endif %}

    {% if relate_to_funders %}
    -- Funders
    {#
      This SQL block UNNESTS the 'UNNEST(affiliations.funders)' section of the DOI table. By doing this, it creates a new rows for each funder listed
      The WHERE statement 'relation.identifier <> aggregrate.identifier' ignores the identifer that is the subject of the overall GROUP BY statement
      The aggregrate.identifer is only relevant where this is creating the funders table, as this code is used to create a range of dervied tables

      The end goal is to pass on a list of objects to the process_relations function, which is able to compute summaries for each identified funder
    #}
    process_relations(
      ARRAY_CONCAT_AGG(ARRAY((
        SELECT AS STRUCT
          relation,
          unpaywall,
          STRUCT(
            dois.openalex.cited_by_count        AS openalex,
            dois.crossref.references_count      AS crossref,
            dois.open_citations.citations_total AS open_citations,
            dois.mag.CitationCount              AS mag
          )         AS citations,
          ARRAY(
            SELECT AS STRUCT
              display_name    AS DisplayName,
              Score           AS Score,
              unpaywall.is_oa AS is_oa
            FROM UNNEST(openalex.concepts) AS fields
            WHERE fields.level = 0
          )         AS disciplines
        FROM UNNEST(affiliations.funders) AS relation
        WHERE relation.identifier <> aggregrate.identifier
      ))),
      COUNT(dois.doi),
      COUNTIF(unpaywall.is_oa = TRUE)
    )                                       AS funders,
    {% endif %}

    {% if relate_to_members %}
    -- Members
    {#
      This SQL block UNNESTS the 'UNNEST(affiliations.members)' section of the DOI table. By doing this, it creates a new rows for each member listed
      Members are only relevant for generating the country and groups tables, as both of these types have 'members' that make up the whole

      The end goal is to pass on a list of objects to the process_relations function, which is able to compute summaries for each identified member
    #}
    process_relations(
      ARRAY_CONCAT_AGG(ARRAY((
        SELECT AS STRUCT
          STRUCT(
            relation             AS identifier,
            relation             AS name,
            CAST(NULL AS STRING) AS country,
            CAST(NULL AS STRING) AS country_code,
            CAST(NULL AS STRING) AS region,
            CAST(NULL AS STRING) AS subregion,
            CAST(NULL AS STRING) AS coordinates
          )         AS relation,
          unpaywall,
          STRUCT(
            dois.openalex.cited_by_count        AS openalex,
            dois.crossref.references_count      AS crossref,
            dois.open_citations.citations_total AS open_citations,
            dois.mag.CitationCount              AS mag
          )         AS citations,
          ARRAY(
            SELECT AS STRUCT
              display_name    AS DisplayName,
              Score           AS Score,
              unpaywall.is_oa AS is_oa
            FROM UNNEST(openalex.concepts) AS fields
            WHERE fields.level = 0
          )         AS disciplines
        FROM UNNEST(aggregrate.members) AS relation
      ))),
      COUNT(dois.doi),
      COUNTIF(unpaywall.is_oa = TRUE)
    )                                       AS members,
    {% endif %}

    {% if relate_to_publishers %}
    {#
      This SQL block UNNESTS the 'UNNEST(affiliations.publishers)' section of the DOI table. By doing this, it creates a new rows for each publihser listed
      The WHERE statement 'relation.identifier <> aggregrate.identifier' ignores the identifer that is the subject of the overall GROUP BY statement
      The aggregrate.identifer is only relevant where this is creating the publishers table, as this code is used to create a range of dervied tables

      The end goal is to pass on a list of objects to the process_relations function, which is able to compute summaries for each identified publisher
    #}
    -- Publishers
    process_relations(
      ARRAY_CONCAT_AGG(ARRAY((
        SELECT AS STRUCT
          relation,
          unpaywall,
          STRUCT(
            dois.openalex.cited_by_count        AS openalex,
            dois.crossref.references_count      AS crossref,
            dois.open_citations.citations_total AS open_citations,
            dois.mag.CitationCount              AS mag
          )         AS citations,
          ARRAY(
            SELECT AS STRUCT
              display_name    AS DisplayName,
              Score           AS Score,
              unpaywall.is_oa AS is_oa
            FROM UNNEST(openalex.concepts) AS fields
            WHERE fields.level = 0
          )         AS disciplines
        FROM UNNEST(affiliations.publishers) AS relation
        WHERE relation.identifier <> aggregrate.identifier
      ))),
      COUNT(dois.doi),
      COUNTIF(unpaywall.is_oa = TRUE)
    )                                       AS publishers,
    {% endif %}

    {% if relate_to_journals %}
    -- Journals
    {#
      This SQL block UNNESTS the 'UNNEST(affiliations.journals)' section of the DOI table. By doing this, it creates a new rows for each journal listed
      The WHERE statement 'relation.identifier <> aggregrate.identifier' ignores the identifer that is the subject of the overall GROUP BY statement
      The aggregrate.identifer is only relevant where this is creating the journals table, as this code is used to create a range of dervied tables

      The end goal is to pass on a list of objects to the process_relations function, which is able to compute summaries for each identified journal
    #}
    process_relations(
      ARRAY_CONCAT_AGG(ARRAY((
        SELECT as STRUCT
          relation,
          unpaywall,
          STRUCT(
            dois.openalex.cited_by_count        AS openalex,
            dois.crossref.references_count      AS crossref,
            dois.open_citations.citations_total AS open_citations,
            dois.mag.CitationCount              AS mag
          )         AS citations,
          ARRAY(
            SELECT AS STRUCT
              display_name    AS DisplayName,
              Score           AS Score,
              unpaywall.is_oa AS is_oa
            FROM UNNEST(openalex.concepts) AS fields
            WHERE fields.level = 0
          )         AS disciplines
        FROM UNNEST(affiliations.journals) AS relation
        WHERE relation.identifier <> aggregrate.identifier
      ))),
      COUNT(dois.doi),
      COUNTIF(unpaywall.is_oa = TRUE)
    )                                       AS journals,
    {% endif %}

    -- Events
    {#
      This SQL block UNNESTS the 'UNNEST(dois.events.events)' section of the DOI table.
      It concatinates all the individual event types and counts, along with the OA status of the DOIs those events are linked too
      The end goal of this block is to pass the resulting list into the process_events function to create the summary you see in the final output
    #}
    -- FIXME: is there an error here? Missing two arguments to process_events()
    process_events(ARRAY_CONCAT_AGG(ARRAY((
      SELECT AS STRUCT
        event.source,
        event.count,
        STRUCT(
          dois.openalex.cited_by_count        AS openalex,
          dois.crossref.references_count      AS crossref,
          dois.open_citations.citations_total AS open_citations,
          dois.mag.CitationCount              AS mag
        )           AS citations,
        unpaywall.is_oa,
        unpaywall.green,
        unpaywall.gold,
        unpaywall.gold_just_doaj,
        unpaywall.hybrid,
        unpaywall.bronze,
        unpaywall.green_only
      FROM UNNEST(dois.events.events) AS event
    ))))                                    AS events,

  FROM `{{ project_id }}.{{ dataset_id }}.doi{{ release_date.strftime('%Y%m%d') }}` AS dois,
  UNNEST(dois.affiliations.{{ aggregation_field }}) AS aggregrate
  WHERE aggregrate.identifier IS NOT NULL
  GROUP BY aggregrate.identifier, crossref.{{ group_by_time_field }}
)

-- Putting it all together
SELECT
  tmp_agg_table.*,
  disciplines,
  access_types
FROM tmp_agg_table
INNER JOIN tmp_disciplines  ON tmp_agg_table.id = tmp_disciplines.id  AND tmp_agg_table.time_period = tmp_disciplines.time_period
INNER JOIN tmp_access_types ON tmp_agg_table.id = tmp_access_types.id AND tmp_agg_table.time_period = tmp_access_types.time_period

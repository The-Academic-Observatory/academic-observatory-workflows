{#
  # Copyright 2020 Curtin University
  #
  # Licensed under the Apache License, Version 2.0 (the "License");
  # you may not use this file except in compliance with the License.
  # You may obtain a copy of the License at
  #
  #   http://www.apache.org/licenses/LICENSE-2.0
  #
  # Unless required by applicable law or agreed to in writing, software
  # distributed under the License is distributed ON an "AS IS" BASIS,
  # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  # See the License for the specific language governing permissions and
  # limitations under the License.

  # Author: Richard Hosking, James Diprose
#}
-- Create a table of DOI to ROR affiliations, including direct affiliations (author_rors) and indirect affiliations through the ROR parent relationships (hierarchy_rors)
WITH
coki_affiliations_temp AS (
  SELECT
  coki_affiliations.doi                                                     AS doi,
  author_institutions                                                       AS author_institutions,
  ARRAY(SELECT DISTINCT * FROM coki_affiliations.genealogical_institutions) AS genealogical_institutions
  FROM (
    SELECT
      openalex.doi                                            AS doi,
      ARRAY_AGG(DISTINCT ror_hierarchy.child_id IGNORE NULLS) AS author_institutions,
      ARRAY_CONCAT_AGG(ror_hierarchy.ror_ids)                 AS genealogical_institutions
    FROM `{{ observatory_intermediate.project_id }}.{{ observatory_intermediate.dataset_id }}.openalex{{ release_date.strftime('%Y%m%d') }}` AS openalex,
    UNNEST(IFNULL(openalex.authorships,[])) AS authors,
    UNNEST(IFNULL(authors.institutions,[])) AS institution
    LEFT JOIN `{{ observatory_intermediate.project_id }}.{{ observatory_intermediate.dataset_id }}.ror_hierarchy{{ release_date.strftime('%Y%m%d') }}` AS ror_hierarchy ON ror_hierarchy.child_id = institution.ror
    GROUP BY openalex.doi) AS coki_affiliations
),

{# This query, using crossref metadata AS the reference, links together all the other tables that expose objects with doi AS the primary key #}
dois_temp_table AS (
  SELECT * FROM (
    SELECT
      {# This SQL block links unpaywall, mag, open citations and crossref events to the DOI and the metadata found in the crossref metadata dataset #}
      UPPER(TRIM(ref.doi))  AS doi,
      STRUCT(
        title,
        abstract,
        issued.date_parts[offset(0)] AS published_year,
        IF(ARRAY_LENGTH(issued.date_parts) > 1, issued.date_parts[offset(1)], 13) AS published_month,
        CONCAT(issued.date_parts[offset(0)], "-", IF(ARRAY_LENGTH(issued.date_parts) > 1, issued.date_parts[offset(1)], 13)) AS published_year_month,
        type,
        ISSN,
        ISBN,
        issn_type,
        publisher_location,
        publisher,
        member,
        prefix,
        container_title,
        short_container_title,
        group_title,
        references_count,
        is_referenced_by_count,
        subject,
        published_print,
        license, volume,
        funder,
        page,
        author,
        link,
        clinical_trial_number,
        alternative_id
      )                     AS crossref,
      (
        SELECT AS STRUCT *
        FROM `{{ observatory_intermediate.project_id }}.{{ observatory_intermediate.dataset_id }}.unpaywall{{ release_date.strftime('%Y%m%d') }}` AS oa
        WHERE oa.doi = UPPER(TRIM(ref.doi))
      )                     AS unpaywall,
      (
        SELECT AS STRUCT *
        FROM `{{ observatory_intermediate.project_id }}.{{ observatory_intermediate.dataset_id }}.openalex{{ release_date.strftime('%Y%m%d') }}` AS openalex
        WHERE openalex.doi = UPPER(TRIM(ref.doi))
      )                     AS openalex,
      (
        SELECT AS STRUCT *
        FROM `{{ observatory_intermediate.project_id }}.{{ observatory_intermediate.dataset_id }}.mag{{ release_date.strftime('%Y%m%d') }}` AS mag
        WHERE mag.doi = UPPER(TRIM(ref.doi))
      )                     AS mag,
      (
        SELECT AS STRUCT *
        FROM `{{ observatory_intermediate.project_id }}.{{ observatory_intermediate.dataset_id }}.open_citations{{ release_date.strftime('%Y%m%d') }}` AS oa
        WHERE oa.doi = UPPER(TRIM(ref.doi))
      )                     AS open_citations,
      (
        SELECT AS STRUCT *
        FROM `{{ observatory_intermediate.project_id }}.{{ observatory_intermediate.dataset_id }}.crossref_events{{ release_date.strftime('%Y%m%d') }}` AS events
        WHERE events.doi = UPPER(TRIM(ref.doi))
      )                     AS events,
      (
        SELECT AS STRUCT *
        FROM coki_affiliations_temp AS coki_affiliations
        WHERE coki_affiliations.doi = UPPER(TRIM(ref.doi))
      )                     AS coki_affiliations
    FROM `{{ crossref_metadata.project_id }}.{{ crossref_metadata.dataset_id }}.crossref_metadata{{ crossref_metadata.release_date.strftime('%Y%m%d') }}` AS ref
    WHERE ARRAY_LENGTH(issued.date_parts) > 0
  )
),

{# this query builds the .affiliation section of the final doi table. The primary purpose of this is to allow the aggregrate_doi query #}
affiliations_temp_table AS (
  SELECT
    extras.doi AS doi,
    institutions,
    {#
      The four affiliation types below (Country, SubRegion, Region and Grouping, take their values from the SubQuery Below 'LEFT JOIN( SELECT...' however they need to be GROUPed to ensure only unique lists.
      For example, two institutions in one country result in two records of the same counry and a squashed into a single instance
    #}
    -- countries
    ARRAY(
      SELECT AS STRUCT
        identifier                                         AS identifier,
        MAX(name)                                          AS name,
        ["Country"]                                        AS types,
        CAST(MAX(country)        AS STRING)                AS country,
        CAST(MAX(country_code)   AS STRING)                AS country_code,
        CAST(MAX(country_code_2) AS STRING)                AS country_code_2,
        CAST(MAX(region)         AS STRING)                AS region,
        CAST(MAX(subregion)      AS STRING)                AS subregion,
        CAST(NULL                AS STRING)                AS coordinates,
        COUNT(*)                                           AS count,
        ARRAY_AGG(DISTINCT member_identifier IGNORE NULLS) AS members
      FROM UNNEST(countries)
      GROUP BY identifier
    ) AS countries,

    -- subregions
    ARRAY(
      SELECT AS STRUCT
        identifier                                         AS identifier,
        MAX(name)                                          AS name,
        ["Subregion"]                                      AS types,
        CAST(MAX(country)        AS STRING)                AS country,
        CAST(MAX(country_code)   AS STRING)                AS country_code,
        CAST(MAX(country_code_2) AS STRING)                AS country_code_2,
        CAST(MAX(region)         AS STRING)                AS region,
        CAST(MAX(subregion)      AS STRING)                AS subregion,
        CAST(NULL                AS STRING)                AS coordinates,
        COUNT(*)                                           AS count,
        ARRAY_AGG(DISTINCT member_identifier IGNORE NULLS) AS members
      FROM UNNEST(subregions)
      GROUP BY identifier
    ) AS subregions,

    -- regions
    ARRAY(
      SELECT AS STRUCT
        identifier                                         AS identifier,
        MAX(name)                                          AS name,
        ["Region"]                                         AS types,
        CAST(MAX(country)        AS STRING)                AS country,
        CAST(MAX(country_code)   AS STRING)                AS country_code,
        CAST(MAX(country_code_2) AS STRING)                AS country_code_2,
        CAST(MAX(region)         AS STRING)                AS region,
        CAST(MAX(subregion)      AS STRING)                AS subregion,
        CAST(NULL                AS STRING)                AS coordinates,
        COUNT(*)                                           AS count, 
        ARRAY_AGG(DISTINCT member_identifier IGNORE NULLS) AS members
      FROM UNNEST(regions)
      GROUP BY identifier
    ) AS regions,

    -- groupings
    ARRAY(
      SELECT AS STRUCT
        grouping_entity.group_id                                      AS identifier,
        MAX(grouping_entity.group_name)                               AS name,
        ["Grouping"]                                                  AS types,
        CAST(NULL AS STRING)                                          AS country,
        MAX(grouping_entity.country_code)                             AS country_code,
        MAX(grouping_entity.country_code)                             AS country_code_2,
        CAST(NULL AS STRING)                                          AS region,
        CAST(NULL AS STRING)                                          AS subregion,
        CAST(NULL AS STRING)                                          AS coordinates,
        -- FIXME: should there be a count here?
        ARRAY_AGG(DISTINCT grid_group.member_identifier IGNORE NULLS) AS members
      FROM
        UNNEST(ror_groups) AS grid_group,
        UNNEST(grid_group.groupings) AS grouping_entity
      GROUP BY grouping_entity.group_id
    ) AS groupings,

    -- Funder
    {#
      Chooses the values that are passed along in the funder affiliations, the schema is matching all other affiliations to enable flexibility of later SQL templates.
      The values from JOINING the funder reference in Crossref metada with the Fundref dataset
    #}
    ARRAY(
      SELECT AS STRUCT
        funder.funder.name                          AS identifier,
        funder.funder.name                          AS name,
        funder.funder.doi                           AS doi,
        ["Funder"]                                  AS types,
        CAST(funder.fundref.country      AS STRING) AS country,
        CAST(funder.fundref.country_code AS STRING) AS country_code,
        CAST(NULL                        AS STRING) AS country_code_2,
        CAST(funder.fundref.region       AS STRING) AS region,
        CAST(NULL                        AS STRING) AS subregion,
        CAST(NULL                        AS STRING) AS coordinates,
        funder.fundref.funding_body_type            AS funding_body_type,
        funder.fundref.funding_body_sub_type        AS funding_body_subtype,
        CAST([] AS ARRAY<STRING>)                   AS members
      FROM UNNEST(fundref.funders) AS funder
    ) AS funders,

    -- Discipline
    {#
      Chooses the values that are passed along in the discipline affiliations, the schema is matching all other affiliations to enable flexibility of later SQL templates.
      The values come from the fields of study in the MAG dataset
    #}
    ARRAY(
      SELECT AS STRUCT
        field.display_name        AS identifier,
        field.display_name        AS name,
        ["Discipline"]            AS types,
        CAST(NULL AS STRING)      AS country,
        CAST(NULL AS STRING)      AS country_code,
        CAST(NULL AS STRING)      AS country_code_2,
        CAST(NULL AS STRING)      AS region,
        CAST(NULL AS STRING)      AS subregion,
        CAST(NULL AS STRING)      AS coordinates,
        CAST([] AS ARRAY<STRING>) AS members
      FROM UNNEST(openalex.concepts) AS field
      WHERE field.level = 0
    ) AS disciplines,

    -- Authors
    {#
      Chooses the values that are passed along in the author affiliations, the schema is matching all other affiliations to enable flexibility of later SQL templates.
      The values come from the ORCID dataset, which is pivotted to index by DOI, which is the primary index in this table
    #}
    ARRAY(
      SELECT AS STRUCT
        author.uri                AS identifier,
        CONCAT(
          author.given_names,
          " ",
          author.family_name
        )                         AS name,
        author.given_names        AS given_names,
        author.family_name        AS family_name,
        ["Author"]                AS types,
        CAST(NULL AS STRING)      AS country,
        CAST(NULL AS STRING)      AS country_code,
        CAST(NULL AS STRING)      AS country_code_2,
        CAST(NULL AS STRING)      AS region,
        CAST(NULL AS STRING)      AS subregion,
        CAST(NULL AS STRING)      AS coordinates,
        CAST([] AS ARRAY<STRING>) AS members
      FROM UNNEST(orcid.orcid) AS author
    ) AS authors,

    -- Journal
    {#
      While there is only ever one Journal for a publication, this single struct is placed inside of an array '[ ]' to ensure it conforms to the same schema AS other affiliation types.
      This enables templated queries downstream to be greatly simplified
    #}
    [STRUCT(
      unpaywall.journal_issn_l          AS identifier,
      unpaywall.normalised_journal_name AS name,
      ["Journal"]                       AS types,
      CAST(NULL AS STRING)              AS country,
      CAST(NULL AS STRING)              AS country_code,
      CAST(NULL AS STRING)              AS country_code_2,
      CAST(NULL AS STRING)              AS region,
      CAST(NULL AS STRING)              AS subregion,
      CAST(NULL AS STRING)              AS coordinates,
      CAST([] AS ARRAY<STRING>)         AS members
    )] AS journals,
  
    -- Publisher
    {#
      While there is only ever one Publisher for a pubication, this single struct is placed inside of an array '[ ]' to ensure it conforms to the same schema AS other affiliation types.
      This enables templated queries downstream to be greatly simplified
    #}
    [STRUCT(
      crossref.publisher        AS identifier,
      crossref.publisher        AS name,
      ["Publisher"]             AS types,
      CAST(NULL AS STRING)      AS country,
      CAST(NULL AS STRING)      AS country_code,
      CAST(NULL AS STRING)      AS country_code_2,
      CAST(NULL AS STRING)      AS region,
      CAST(NULL AS STRING)      AS subregion,
      CAST(NULL AS STRING)      AS coordinates,
      CAST([] AS ARRAY<STRING>) AS members
    )] AS publishers,

  FROM dois_temp_table AS extras
  LEFT JOIN (
    SELECT
      doi,
      {# Chooses the values that are passed along in the institutional affiliations, the schema is matching all other affiliations to enable flexibility of later SQL templates #}
      ARRAY_AGG(
        STRUCT(
          institution.id                      AS identifier,
          institution.types                   AS types,
          institution.name                    AS name,
          institution.country.wikipedia_name  AS country,
          institution.country.alpha3          AS country_code,
          institution.country.alpha2          AS country_code_2,
          institution.country.region          AS region,
          institution.country.subregion       AS subregion,
          CONCAT(
            CAST(institution.addresses[SAFE_OFFSET(0)].lat AS STRING),
            ", ",
            CAST(institution.addresses[SAFE_OFFSET(0)].lng AS STRING)
          )                                   AS coordinates,
          CAST([] AS ARRAY<STRING>)           AS members
        )
      ) AS institutions,

      {# Chooses the values that are passed along in the country affiliations, the schema is matching all other affiliations to enable flexibility of later SQL templates #}
      ARRAY_AGG(
        STRUCT(
          institution.country.alpha3          AS identifier,
          institution.types                   AS types,
          institution.country.wikipedia_name  AS name,
          institution.country.wikipedia_name  AS country,
          institution.country.alpha3          AS country_code,
          institution.country.alpha2          AS country_code_2,
          institution.country.region          AS region,
          institution.country.subregion       AS subregion,
          CAST(NULL AS STRING)                AS coordinates,
          institution.id                      AS member_identifier
        )
      ) AS countries,

      {# Chooses the values that are passed along in the subregional affiliations, the schema is matching all other affiliations to enable flexibility of later SQL templates #}
      ARRAY_AGG(
        STRUCT(
          institution.country.subregion AS identifier,
          CAST([] AS ARRAY<STRING>)     AS types,
          institution.country.subregion AS name,
          CAST(NULL AS STRING)          AS country,
          CAST(NULL AS STRING)          AS country_code,
          CAST(NULL AS STRING)          AS country_code_2,
          institution.country.region    AS region,
          CAST(NULL AS STRING)          AS subregion,
          CAST(NULL AS STRING)          AS coordinates,
          institution.country.alpha3    AS member_identifier
        )
      ) AS subregions,

      {# Chooses the values that are passed along in the regional affiliations, the schema is matching all other affiliations to enable flexibility of later SQL templates #}
      ARRAY_AGG(
        STRUCT(
          institution.country.region    AS identifier,
          CAST([] AS ARRAY<STRING>)     AS types,
          institution.country.region    AS name,
          CAST(NULL AS STRING)          AS country,
          CAST(NULL AS STRING)          AS country_code,
          CAST(NULL AS STRING)          AS country_code_2,
          institution.country.region    AS region,
          CAST(NULL AS STRING)          AS subregion,
          CAST(NULL AS STRING)          AS coordinates,
          institution.country.subregion AS member_identifier
        )
      ) AS regions,
  
      ARRAY_AGG(
        STRUCT(
          ror_groups.groupings AS groupings,
          institution.id       AS member_identifier
        )
      ) AS ror_groups,

    {#
      dois_temp_table is created AS the first sub-query in this script. It contains the data from crossref, unpaywall, openalex, mag, open_citations and crossref events
      This is then LEFT JOINed against the ROR dataset to take the raw ROR IDs that come from the OpenAlex dataset, with a more detailed view of that institution and its location. The county and region information comes from here
      This Instituional information is JOINed against a COKI created dataset, groupings, which allows for arbitrary grouping of institutions (or really RORs).

      Lastly, Fundref and ORCID are also LEFT JOINed in order to drive the Funder and Author relationships
    #}
    FROM dois_temp_table AS dois,
    UNNEST(coki_affiliations.genealogical_institutions) AS ror_id
    LEFT JOIN `{{ observatory_intermediate.project_id }}.{{ observatory_intermediate.dataset_id }}.ror{{ release_date.strftime('%Y%m%d') }}` AS institution ON ror_id = institution.id
    LEFT JOIN (
      SELECT
        ror,
        ARRAY_AGG(STRUCT(
          group_id,
          group_name,
          country_code
        )) AS groupings
      FROM `{{ settings.project_id }}.{{ settings.dataset_id }}.groupings`
      CROSS JOIN UNNEST(rors) AS ror
      GROUP BY ror
    ) AS ror_groups ON institution.id = ror_groups.ror
    GROUP BY doi
  ) AS base ON extras.doi = base.doi
  LEFT JOIN `{{ observatory_intermediate.project_id }}.{{ observatory_intermediate.dataset_id }}.crossref_fundref{{ release_date.strftime('%Y%m%d') }}` AS fundref ON fundref.doi = extras.doi
  LEFT JOIN `{{ observatory_intermediate.project_id }}.{{ observatory_intermediate.dataset_id }}.orcid{{ release_date.strftime('%Y%m%d') }}` AS orcid ON UPPER(TRIM(orcid.doi)) = UPPER(TRIM(extras.doi))
)

{#
  Brings together the two temporary tables above.
  - dois.* is the collective metadata linked to the doi in question
  - affiliations is the derived data that neatly organises all the relationships a doi has to authors, their institutions, countries and regions of those institutions, publisher, journal, funders
#}
SELECT
  dois.* EXCEPT (coki_affiliations, unpaywall),
  -- Put the unpaywall struct back how it used to be for backwards compatibility
  (SELECT AS STRUCT
    dois.unpaywall.* EXCEPT(repositories, oa_color, oa_license, oa_coki),
    dois.unpaywall.oa_color.*,
    dois.unpaywall.oa_license.*
  ) AS unpaywall,
  -- The coki struct, which contains fields for a work generated by COKI
  STRUCT(
    dois.unpaywall.oa_color,
    dois.unpaywall.oa_license,
    dois.unpaywall.oa_coki,
    dois.unpaywall.repositories,
    STRUCT(
      dois.coki_affiliations.author_institutions,
      dois.coki_affiliations.genealogical_institutions
    ) AS affiliation
  ) AS coki,
  affiliations
FROM dois_temp_table AS dois
LEFT JOIN affiliations_temp_table AS affiliations ON affiliations.doi = dois.doi
